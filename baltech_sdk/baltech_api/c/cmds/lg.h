/**
 * @file
 * @anchor Lg
 * This command group provides access to the _LEGIC Prime_ card system.
 * 
 * This command group is only available for readers equipped with the LEGIC prime
 * reader module SM05!
 */
/**
 * @file
 * @defgroup baltech_api Baltech API
 * @{
 */
#ifndef __BRP_BALTECH_API_CMDS_LG_H__
#define __BRP_BALTECH_API_CMDS_LG_H__
#include "../typedefs.h"
/**
 * @anchor Lg_ErrNomim
 * No LEGIC Prime card detected.
 */
#define BRP_Lg_ErrNomim BRP_ERR_STATUS(0x1100, 0x01)
/**
 * @anchor Lg_ErrInvalidCmd
 * Either the desired command is impossible to execute because no card is
 * currently selected, or the specified parameters are invalid (e.g. wrong
 * address, to many Bytes specified for reading/writing, ...). This status code
 * may also come up when the [Lg.Select](@ref Lg_Select) command is executed when
 * less than 5 Bytes to read are specified and access has been denied.
 * 
 * A card that was already selected before execution of the command triggering
 * this status code will stay selected.
 */
#define BRP_Lg_ErrInvalidCmd BRP_ERR_STATUS(0x1100, 0x02)
/**
 * @anchor Lg_ErrAccessDenied
 * Read/write not allowed due to the access conditions flags of the selected
 * card/segment.
 * 
 * A card that was already selected before execution of the command triggering
 * this status code will stay selected.
 */
#define BRP_Lg_ErrAccessDenied BRP_ERR_STATUS(0x1100, 0x03)
/**
 * @anchor Lg_ErrHf
 * Error occurred while transferring data via the HF field.
 * 
 * An occurrence of this error makes it necessary to reselect the card with the
 * [Lg.Select](@ref Lg_Select) command for further communication.
 */
#define BRP_Lg_ErrHf BRP_ERR_STATUS(0x1100, 0x04)
/**
 * @anchor Lg_ErrDataCorrupt
 * Data has been corrupted during transmission between the reader and the card.
 * 
 * **In case this error is generated by the[ Lg.WriteMIM](@ref Lg_WriteMIM) command
 * or by the[ Lg.WriteMIMCRC](@ref Lg_WriteMIMCRC) command, corrupted data may have
 * been written to the card. Please make sure to rewrite the data correctly to
 * ensure consistency.**
 * 
 * An occurrence of this error makes it necessary to reselect the card with the
 * [Lg.Select](@ref Lg_Select) command for further communication.
 */
#define BRP_Lg_ErrDataCorrupt BRP_ERR_STATUS(0x1100, 0x05)
/**
 * @anchor Lg_ErrCrc
 * CRC checksum invalid.
 * 
 * A card that was already selected before execution of the command triggering
 * this status code will stay selected.
 */
#define BRP_Lg_ErrCrc BRP_ERR_STATUS(0x1100, 0x06)
/**
 * @anchor Lg_ErrCommunication
 * Checksum error most likely occurred in internal communication. It is
 * recommended to repeat the command.
 * 
 * A card that was already selected before execution of the command triggering
 * this status code will stay selected.
 */
#define BRP_Lg_ErrCommunication BRP_ERR_STATUS(0x1100, 0x07)
/**
 * @anchor Lg_ErrMimCorrupt
 * Card is corrupted and may not longer be used.
 */
#define BRP_Lg_ErrMimCorrupt BRP_ERR_STATUS(0x1100, 0x08)
/**
 * @anchor Lg_ErrBusy
 * The SM05 is busy and cannot process the command. Please wait until
 * communication with the SM05 is finished.
 */
#define BRP_Lg_ErrBusy BRP_ERR_STATUS(0x1100, 0x09)
/**
 * @anchor Lg_NotInitialized
 * The SC-2560 is still powering up and is not available yet.
 */
#define BRP_Lg_NotInitialized BRP_ERR_STATUS(0x1100, 0x0A)
/**
 * @anchor Lg_Select
 * This command selects a specific segment of a LEGIC Prime card and reads some
 * data from it.
 * 
 * This command can both access IM cards (standard LEGIC Prime cards containing
 * user data) and SAM cards (used for security purposes).
 * 
 * If no label can be detected, the [Lg.Idle](@ref Lg_Idle) command is implicitly
 * called in order to switch off the HF field. Otherwise, the selected label will
 * stay selected until either a new call of the Lg.Select command is performed,
 * until the [Lg.Idle](@ref Lg_Idle) command is called, if the selected MIM gets out
 * of the HF field, or if the [Lg.ErrDataCorrupt](@ref Lg_ErrDataCorrupt) error
 * occurs.
 * 
 * If several segments are present on the card, only the first segment is
 * directly accessible by the reader. All other segments have to be found by
 * "jumping" from segment to segment. Therefore the time for selecting a certain
 * segment is:
 * 
 * t = 80 ms + SegID * 22 ms
 * 
 * If several segments on the selected card must be accessed, it is recommended
 * to always start with the segment which has the lowest ID.
 * 
 * The protocol header-based addressing mode should always be used. The physical
 * addressing mode is only applicable for unsegmented MIMs and is therefore
 * deprecated.
 * 
 * If the desired data is protected against reading, then the first 5 Bytes of
 * the segment, according to the protocol header addressing, will be returned in
 * the _Data_ variable instead of the requested data. It is recommended to check
 * that the returned value of _Data_ has a length unequal to 5 or to check the
 * value of the returned address in the _ActAdr_ variable to make sure that the
 * requested data has been properly returned.
 * 
 * If an error status code is returned by this command, no card will be selected.
 * 
 * If [Lg.ErrBusy](@ref Lg_ErrBusy) is returned, the reader is still busy with
 * reading a SAM card. This occurs when the _TO_ parameter for this command is to
 * small to wait for the end of this operation. In this case, the reader will
 * reject any LEGIC command by returning the [Lg.ErrBusy](@ref Lg_ErrBusy) status
 * code until the operation is finished and the stamp is stored in the reader's
 * EEPROM.
 * 
 * **To prevent unauthorized writing of stamp data to the reader's EEPROM, it is
 * advisable to use a _TO_ value below 0xA0 in your application software.**
 * 
 * @param[in] protocol used to execute the command
 * @param[in] TO The command timeout is calculated by  _TO_ * 100 ms  _TO_ should be chosen depending on the location of the desired card segment. The default value (0x05) is sufficient for most purposes, but a value > 0xA0 is required to read SAM cards.
 * @param[in] Adr Start address of data on card to read. The default value (7) is the address of the card's serial number.
 * @param[in] Len Length of data to read, in Bytes. The default value (4) is the length of the card's serial number.
 * @param[in] PollTime The required poll time is calculated by  _Time_ * 20 ms  The default value (0x01) is sufficient for most purposes.
 * @param[in] CRCAdr Address of the CRC checksum of the data stored at _Adr_.
 * @param[in] SafeDat If set, the safe data handling mechanism will be used. This mechanism detects if two cards are in the HF field at the same time and returns an error if this is the case.
 * @param[in] ChgSeg If set, a new segment on the already selected card is directly selected without going back to the idle state beforehand. This saves time and ensures that the new segment is located on the already selected card.
 * @param[in] ProtHead If set, use protocol header for addressing, otherwise use physical addresses. For segmented cards, protocol header is mandatory. The chosen addressing mode impacts all following commands working on the currently selected card.
 * @param[in] CRCCalc If set, use 16 bit CRC checksum, otherwise 8 bit. 16 bit CRC is only available when the _ProtHead_ flag is also set.
 * @param[in] CRCChk Enable/disable CRC check.
 * @param[in] SegID ID of desired segment (or start segment for segment search).
 * @param[in] Stamp Stamp Bytes that may be used for selecting a certain segment instead of the segment ID. In this case, the _SegID_ parameter will be used as the start segment for the search. Segments are always searched beginning from the lowest ID.
 * @param[in] Stamp_len 
 * @param[out] MediaType Indicates the type of card that was selected.
 * @param[out] FuncLevel Function level of the card. The function level depends on the type of card:    * 1-16: GAM (General Authorization Media)    * 1-64 (55-64 reserved by LEGIC): SAM (System Authorization Media)    * 1-48 (40-48 reserved by LEGIC): IAM (Identification Authorization Media)    * 0: IM (Identification Media, segmented/unsegmented) / NM (New Media)    * 1: XAM (Extended Authorization Media)
 * @param[out] OrgLevel Organization level of the card. The organization level depends on the type of card:    * 1-12: AM (Authorization Media) / XAM (Extended Authorization Media)    * 0: IM (Identification Media) / NM (New Media)
 * @param[out] EvStat Event Status of operation.
 * @param[out] ActSegID Selected segment, 0x01 - 0x7F for segmented card, 0x00 for unsegmented card.
 * @param[out] ActAdr Address of read data.
 * @param[out] Data Data read from card.
 * @param[out] Data_len 
 * @param[in] mempool is used to store response data. Maybe NULL to use an internal mempool, in this case the data is only available until another command uses the internal mempool
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_Select(brp_protocol protocol, unsigned TO, unsigned Adr, unsigned Len, unsigned PollTime, unsigned CRCAdr, unsigned SafeDat, unsigned ChgSeg, unsigned ProtHead, unsigned CRCCalc, unsigned CRCChk, unsigned SegID, brp_buf Stamp, size_t Stamp_len, brp_Lg_Select_MediaType* MediaType, unsigned* FuncLevel, unsigned* OrgLevel, brp_Lg_Select_EvStat* EvStat, unsigned* ActSegID, unsigned* ActAdr, brp_buf* Data, size_t* Data_len, brp_mempool *mempool);
/**
 * @anchor Lg_Idle
 * Switch power supply of HF field to the level specified in the _PowOff_
 * parameter. Any selected label will no longer be selected.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] PowOff State of the HF field.
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_Idle(brp_protocol protocol, brp_Lg_Idle_PowOff PowOff);
/**
 * @anchor Lg_GenSetRead
 * Read stamp data with ID specified in the _GenSetNum_ parameter from the
 * reader's EEPROM.
 * 
 * **Responses after _StampLen_ are only transmitted when StatusCode is OK and
 * the response length is > 9!**
 * 
 * @param[in] protocol used to execute the command
 * @param[in] DesiredGenSetNum ID number of desired stamp entry (0x01 - 0x10).
 * @param[out] GenSetNum ID number of read stamp entry (0x01 - 0x10).
 * @param[out] Stamp Stamp data.
 * @param[out] StampLen Status of read stamp entry. Possible values:    * 0x00: Stamp with ID specified by _GenSetNum_ has been deleted.    * 0x01 - 0x07: Length of valid stamp Bytes in stamp.    * 0x08 - 0xFF: Stamp with ID specified by _GenSetNum_ not present.
 * @param[out] WriteExLen Length of data for which these extended write conditions are applicable (0x01 - 0xFF).
 * @param[out] WriteExShad Indicated whether or not shadow-memory management features are activated.
 * @param[out] WriteExMode Determines extended write conditions.
 * @param[out] WriteExStart Offset added to the start address of the stamp in the selected segment, indicating the address of the data in this segment for which the extended write access conditions apply.  **This value is always > = 13 since extended write access conditions may not be set for the stamp data itself.**
 * @param[in] mempool is used to store response data. Maybe NULL to use an internal mempool, in this case the data is only available until another command uses the internal mempool
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_GenSetRead(brp_protocol protocol, unsigned DesiredGenSetNum, unsigned* GenSetNum, brp_buf* Stamp, unsigned* StampLen, unsigned* WriteExLen, bool* WriteExShad, brp_Lg_GenSetRead_WriteExMode* WriteExMode, unsigned* WriteExStart, brp_mempool *mempool);
/**
 * @anchor Lg_GenSetDelete
 * Delete stamp data with ID specified in the _GenSetNum_ parameter from the
 * reader's EEPROM.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] GenSetNum ID number of stamp entry to delete (0x01 - 0x10).
 * @param[out] DeletedGenSetNum ID number of deleted stamp entry (0x01 - 0x10).
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_GenSetDelete(brp_protocol protocol, unsigned GenSetNum, unsigned* DeletedGenSetNum);
/**
 * @anchor Lg_ReadMIM
 * Read _Len_ Bytes from the currently selected card/segment, starting at address
 * _Adr_.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] Adr Address of data to read.
 * @param[in] Len Number of Bytes to read (0x01 - 0x20).
 * @param[out] DataAdr Address of read data.
 * @param[out] Data Read data.
 * @param[out] Data_len 
 * @param[in] mempool is used to store response data. Maybe NULL to use an internal mempool, in this case the data is only available until another command uses the internal mempool
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_ReadMIM(brp_protocol protocol, unsigned Adr, unsigned Len, unsigned* DataAdr, brp_buf* Data, size_t* Data_len, brp_mempool *mempool);
/**
 * @anchor Lg_ReadMIMCRC
 * This command is similar to the [Lg.ReadMIM](@ref Lg_ReadMIM) command, except that
 * a CRC checksum is calculated over the read Bytes and compared to the CRC
 * checksum given in the _CRCAdr_ parameter. If these checksums differ, the
 * [Lg.ErrCrc](@ref Lg_ErrCrc) status code will be returned. Depending on the value
 * of the _CRCCalc_ flag given as a parameter in the [Lg.Select](@ref Lg_Select)
 * command, either 8-bit or 16-bit checksums will be used.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] Adr Address of data to read.
 * @param[in] Len Number of Bytes to read (0x01 - 0x20).
 * @param[in] CRCAdr Address of CRC checksum for verification of read data.
 * @param[out] DataAdr Address of read data.
 * @param[out] Data Read data.
 * @param[out] Data_len 
 * @param[in] mempool is used to store response data. Maybe NULL to use an internal mempool, in this case the data is only available until another command uses the internal mempool
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_ReadMIMCRC(brp_protocol protocol, unsigned Adr, unsigned Len, unsigned CRCAdr, unsigned* DataAdr, brp_buf* Data, size_t* Data_len, brp_mempool *mempool);
/**
 * @anchor Lg_WriteMIM
 * Write data to selected card/segment.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] Adr Address of block to write.
 * @param[in] Data Data to write to card.
 * @param[in] Data_len 
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_WriteMIM(brp_protocol protocol, unsigned Adr, brp_buf Data, size_t Data_len);
/**
 * @anchor Lg_WriteMIMCRC
 * This command is similar to the [Lg.WriteMIM](@ref Lg_WriteMIM) command, except
 * that a CRC checksum is calculated over the data to write and compared to the
 * CRC checksum given in the _CRCAdr_ parameter. If these checksums differ, the
 * [Lg.ErrCrc](@ref Lg_ErrCrc) status code will be returned. Depending on the value
 * of the _CRCCalc_ flag given as a parameter in the [Lg.Select](@ref Lg_Select)
 * command, either 8-bit or 16-bit checksums will be used.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] Adr Adress of block to write.
 * @param[in] DataLen Number of Bytes in data buffer.
 * @param[in] CRCAdr Address of CRC checksum for verification of data to write.
 * @param[in] Data Data to write to card.
 * @param[in] Data_len 
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_WriteMIMCRC(brp_protocol protocol, unsigned Adr, unsigned DataLen, unsigned CRCAdr, brp_buf Data, size_t Data_len);
/**
 * @anchor Lg_MakeMIMCRC
 * Create CRC checksum at _CRCAdr_ for a data block of length _Len_ present at
 * address _Adr_. Depending on the value of the _CRCCalc_ flag given as a
 * parameter in the [Lg.Select](@ref Lg_Select) command, either an 8-bit or 16-bit
 * checksum will be created.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] Adr Address of block to use for CRC calculation.
 * @param[in] Len Number of Bytes included in CRC calculation.
 * @param[in] CRCAdr Address of the calculated CRC checksum.
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_MakeMIMCRC(brp_protocol protocol, unsigned Adr, unsigned Len, unsigned CRCAdr);
/**
 * @anchor Lg_ReadSMStatus
 * Retrieve status information from LEGIC prime SM 05 chip as well as information
 * from the currently selected MIM.
 * 
 * @param[in] protocol used to execute the command
 * @param[out] RFU 
 * @param[out] SWV Firmware-Version of SM 05
 * @param[out] SmStat Firmware status code (Baltech internal use only).
 * @param[out] HfPow HF Transmission power (0: off).
 * @param[out] NoMIM If this flag is set, there is no valid MIM in the field of the antenna.
 * @param[out] MIMVersion Size of detected MIM.
 * @param[in] mempool is used to store response data. Maybe NULL to use an internal mempool, in this case the data is only available until another command uses the internal mempool
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_ReadSMStatus(brp_protocol protocol, brp_buf* RFU, unsigned* SWV, unsigned* SmStat, unsigned* HfPow, bool* NoMIM, brp_Lg_ReadSMStatus_MIMVersion* MIMVersion, brp_mempool *mempool);
/**
 * @anchor Lg_SetPassword
 * Activates password protection for the SC-2560.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] Password Password.
 * @param[out] PwdStat Password protection status.
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_SetPassword(brp_protocol protocol, brp_buf Password, brp_Lg_SetPassword_PwdStat* PwdStat);
/**
 * @anchor Lg_Lock
 * Locks the SC-2560.
 * 
 * @param[in] protocol used to execute the command
 * @param[out] PwdStat Password protection status.
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_Lock(brp_protocol protocol, brp_Lg_Lock_PwdStat* PwdStat);
/**
 * @anchor Lg_Unlock
 * Unlocks the SC-2560 with a password.
 * 
 * @param[in] protocol used to execute the command
 * @param[in] Password 
 * @param[out] PwdStat Password protection status.
 * @deprecated This command may be removed in future!
 */
brp_errcode brp_Lg_Unlock(brp_protocol protocol, brp_buf Password, brp_Lg_Unlock_PwdStat* PwdStat);
#endif
/**
 * @}
 */
